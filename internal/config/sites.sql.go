// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: sites.sql

package config

import (
	"context"
	"time"
)

const addSite = `-- name: AddSite :exec
INSERT INTO sites (db_name, link, update_date, auto_update, enabled) VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING
`

type AddSiteParams struct {
	DbName     string    `json:"dbName"`
	Link       string    `json:"link"`
	UpdateDate time.Time `json:"updateDate"`
	AutoUpdate bool      `json:"autoUpdate"`
	Enabled    bool      `json:"enabled"`
}

func (q *Queries) AddSite(ctx context.Context, arg AddSiteParams) error {
	_, err := q.db.ExecContext(ctx, addSite,
		arg.DbName,
		arg.Link,
		arg.UpdateDate,
		arg.AutoUpdate,
		arg.Enabled,
	)
	return err
}

const getSite = `-- name: GetSite :one
SELECT db_name, link, update_date, auto_update, enabled FROM sites WHERE db_name = $1
`

func (q *Queries) GetSite(ctx context.Context, dbName string) (Site, error) {
	row := q.db.QueryRowContext(ctx, getSite, dbName)
	var i Site
	err := row.Scan(
		&i.DbName,
		&i.Link,
		&i.UpdateDate,
		&i.AutoUpdate,
		&i.Enabled,
	)
	return i, err
}

const listSites = `-- name: ListSites :many
SELECT db_name, link, update_date, auto_update, enabled FROM sites ORDER BY link
`

func (q *Queries) ListSites(ctx context.Context) ([]Site, error) {
	rows, err := q.db.QueryContext(ctx, listSites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Site
	for rows.Next() {
		var i Site
		if err := rows.Scan(
			&i.DbName,
			&i.Link,
			&i.UpdateDate,
			&i.AutoUpdate,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSite = `-- name: RemoveSite :exec
DELETE FROM sites WHERE db_name = $1
`

func (q *Queries) RemoveSite(ctx context.Context, dbName string) error {
	_, err := q.db.ExecContext(ctx, removeSite, dbName)
	return err
}
