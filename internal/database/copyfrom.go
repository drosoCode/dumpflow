// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: copyfrom.go

package database

import (
	"context"
)

// iteratorForAddBadge implements pgx.CopyFromSource.
type iteratorForAddBadge struct {
	rows                 []AddBadgeParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddBadge) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddBadge) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].UserID,
		r.rows[0].Name,
		r.rows[0].Date,
		r.rows[0].Class,
		r.rows[0].TagBased,
	}, nil
}

func (r iteratorForAddBadge) Err() error {
	return nil
}

func (q *Queries) AddBadge(ctx context.Context, arg []AddBadgeParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"badges"}, []string{"id", "user_id", "name", "date", "class", "tag_based"}, &iteratorForAddBadge{rows: arg})
}

// iteratorForAddComment implements pgx.CopyFromSource.
type iteratorForAddComment struct {
	rows                 []AddCommentParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddComment) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddComment) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PostID,
		r.rows[0].Score,
		r.rows[0].Text,
		r.rows[0].CreationDate,
		r.rows[0].UserID,
		r.rows[0].ContentLicense,
	}, nil
}

func (r iteratorForAddComment) Err() error {
	return nil
}

func (q *Queries) AddComment(ctx context.Context, arg []AddCommentParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"comments"}, []string{"id", "post_id", "score", "text", "creation_date", "user_id", "content_license"}, &iteratorForAddComment{rows: arg})
}

// iteratorForAddPost implements pgx.CopyFromSource.
type iteratorForAddPost struct {
	rows                 []AddPostParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddPost) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddPost) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PostTypeID,
		r.rows[0].ParentID,
		r.rows[0].AcceptedAnswerID,
		r.rows[0].CreationDate,
		r.rows[0].Score,
		r.rows[0].ViewCount,
		r.rows[0].Body,
		r.rows[0].AnswerCount,
		r.rows[0].CommentCount,
		r.rows[0].FavoriteCount,
		r.rows[0].ContentLicense,
		r.rows[0].ClosedDate,
		r.rows[0].Tags,
	}, nil
}

func (r iteratorForAddPost) Err() error {
	return nil
}

func (q *Queries) AddPost(ctx context.Context, arg []AddPostParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"posts"}, []string{"id", "post_type_id", "parent_id", "accepted_answer_id", "creation_date", "score", "view_count", "body", "answer_count", "comment_count", "favorite_count", "content_license", "closed_date", "tags"}, &iteratorForAddPost{rows: arg})
}

// iteratorForAddPostHistory implements pgx.CopyFromSource.
type iteratorForAddPostHistory struct {
	rows                 []AddPostHistoryParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddPostHistory) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddPostHistory) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PostHistoryTypeID,
		r.rows[0].PostID,
		r.rows[0].RevisionGuid,
		r.rows[0].CreationDate,
		r.rows[0].UserID,
		r.rows[0].Comment,
		r.rows[0].Text,
		r.rows[0].ContentLicense,
	}, nil
}

func (r iteratorForAddPostHistory) Err() error {
	return nil
}

func (q *Queries) AddPostHistory(ctx context.Context, arg []AddPostHistoryParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"post_history"}, []string{"id", "post_history_type_id", "post_id", "revision_guid", "creation_date", "user_id", "comment", "text", "content_license"}, &iteratorForAddPostHistory{rows: arg})
}

// iteratorForAddPostLink implements pgx.CopyFromSource.
type iteratorForAddPostLink struct {
	rows                 []AddPostLinkParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddPostLink) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddPostLink) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreationDate,
		r.rows[0].PostID,
		r.rows[0].RelatedPostID,
		r.rows[0].LinkTypeID,
	}, nil
}

func (r iteratorForAddPostLink) Err() error {
	return nil
}

func (q *Queries) AddPostLink(ctx context.Context, arg []AddPostLinkParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"post_links"}, []string{"id", "creation_date", "post_id", "related_post_id", "link_type_id"}, &iteratorForAddPostLink{rows: arg})
}

// iteratorForAddTag implements pgx.CopyFromSource.
type iteratorForAddTag struct {
	rows                 []AddTagParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddTag) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddTag) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].TagName,
		r.rows[0].Count,
		r.rows[0].IsRequired,
		r.rows[0].IsModeratorOnly,
		r.rows[0].WikiPostID,
		r.rows[0].ExcerptPostID,
	}, nil
}

func (r iteratorForAddTag) Err() error {
	return nil
}

func (q *Queries) AddTag(ctx context.Context, arg []AddTagParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"tags"}, []string{"id", "tag_name", "count", "is_required", "is_moderator_only", "wiki_post_id", "excerpt_post_id"}, &iteratorForAddTag{rows: arg})
}

// iteratorForAddUser implements pgx.CopyFromSource.
type iteratorForAddUser struct {
	rows                 []AddUserParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddUser) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddUser) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Reputation,
		r.rows[0].CreationDate,
		r.rows[0].DisplayName,
		r.rows[0].LastAccessDate,
		r.rows[0].Location,
		r.rows[0].WebsiteUrl,
		r.rows[0].AboutMe,
		r.rows[0].Views,
		r.rows[0].Upvotes,
		r.rows[0].Downvotes,
		r.rows[0].AccountID,
		r.rows[0].ProfileImageUrl,
	}, nil
}

func (r iteratorForAddUser) Err() error {
	return nil
}

func (q *Queries) AddUser(ctx context.Context, arg []AddUserParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"users"}, []string{"id", "reputation", "creation_date", "display_name", "last_access_date", "location", "website_url", "about_me", "views", "upvotes", "downvotes", "account_id", "profile_image_url"}, &iteratorForAddUser{rows: arg})
}

// iteratorForAddVote implements pgx.CopyFromSource.
type iteratorForAddVote struct {
	rows                 []AddVoteParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddVote) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddVote) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PostID,
		r.rows[0].VoteTypeID,
		r.rows[0].CreationDate,
	}, nil
}

func (r iteratorForAddVote) Err() error {
	return nil
}

func (q *Queries) AddVote(ctx context.Context, arg []AddVoteParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"votes"}, []string{"id", "post_id", "vote_type_id", "creation_date"}, &iteratorForAddVote{rows: arg})
}
